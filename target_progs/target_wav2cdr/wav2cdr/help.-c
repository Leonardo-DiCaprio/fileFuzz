"wav2cdr(1)                                                          wav2cdr(1)\n"
"\n"
"NAME\n"
"       wav2cdr  -  converts  input in (or similar to) wav format to cdr format\n"
"       suitable for writing onto audio CDs.\n"
"\n"
"SYNOPSIS\n"
"       wav2cdr [options ...] [infile [outfile]] [--cut cutnumber ...]\n"
"\n"
"VERSION\n"
"       This man page describes wav2cdr version 2.3.4.\n"
"\n"
"DESCRIPTION\n"
"       wav2cdr is a conversion program for audio data which  adopts  automati-\n"
"       cally to big and little endian machines. Its primary use was to convert\n"
"       wav to cdr, but it is a little more flexible now and  can  handle  some\n"
"       file formats and perform some operations on the data. These formats are\n"
"       possible (reading and writing):\n"
"\n"
"           wav   MS Windows sound\n"
"           cdr   audio CD\n"
"           raw   fixed sampling rate, channels, and bytes per sample\n"
"                 (= that of cdr); byte order must be specified\n"
"\n"
"       These operations can be performed on the data (combinations are  possi-\n"
"       ble as long as they are meaningful):\n"
"\n"
"           Scaling (volume change), integer arithmetic\n"
"           Scaling (volume change), floating point arithmetic\n"
"           Cutting of the input into pieces / tracks\n"
"           Conversion to mono and back to stereo\n"
"           Swapping of the 2 channels\n"
"           Adding silence to (or removing from, see cutting) the\n"
"             start and/or end\n"
"           Generation of cut numbers along silent intervals, e.g.\n"
"             to break up a record into tracks\n"
"           Information about non-silent intervals\n"
"           Fading in and out\n"
"\n"
"OPTIONS\n"
"       --cut NUM NUM [NUM...]\n"
"              Cut  the  input into pieces, cutting at positions NUM.  See sec-\n"
"              tions about argument scanning and splitting below.\n"
"\n"
"       --endsilence, --es DUR\n"
"              Adds the given amount of silence to the end of each output file.\n"
"\n"
"       --fadein LEN\n"
"              Fade in at the start over a duration of LEN.  The syntax for LEN\n"
"              is the same as for a cut  number,  see  section  about  argument\n"
"              scanning below.  If cutting is active, fade-in is applied to the\n"
"              beginning of each cut.\n"
"\n"
"              Fading in is performed by increasing the amplitude for  CD  sec-\n"
"              tors  by  an  amount  derived  from  LEN over a duration of LEN.\n"
"              --fadein 3 would result in the amplitude  of  the  first  sector\n"
"              lowered  to 1/4, of the second sector to 2/4, and the third sec-\n"
"              tor to 3/4. The fourth sector is unchanged and has then  reached\n"
"              full amplitude.\n"
"\n"
"       --fadeout LEN\n"
"              Fade  out at the end over a duration of LEN.  The syntax for LEN\n"
"              is the same as for a cut  number,  see  section  about  argument\n"
"              scanning below.  If cutting is active, fad-out is applied to the\n"
"              end of each cut.\n"
"\n"
"              The computation is similar to --fadein. --fadein 3 would  result\n"
"              in the last 3 CD sectors having their amplitudes lowered to 3/4,\n"
"              2/4, and 1/4. The (non-existant) following sector is assumed  to\n"
"              be silent.\n"
"\n"
"              To add silent sector(s) to the end of the audio file, use --end-\n"
"              silence.\n"
"\n"
"              Fading out can only be performed if the input size can be deter-\n"
"              mined (i.e. the input must be seekable and cannot be a pipe). If\n"
"              cutting is active, the end of the cut is always  known  and  the\n"
"              fade-out can be applied.\n"
"\n"
"              If the fade-out starts before the fade-in is finished, both will\n"
"              overlap, producing sensible results.\n"
"\n"
"       --fscale FLOAT\n"
"              Scale data by FLOAT, i.e. multiply by FLOAT (1.0 does  nothing).\n"
"\n"
"       -h, -u, --usage\n"
"              Display usage.\n"
"\n"
"       --help Display  extensive  help.  (The  information is derived from and\n"
"              equivalent to this manual page.)\n"
"\n"
"       --inbig, -I\n"
"              Input data is big endian (MSB, LSB) (Motorola).\n"
"\n"
"       --incdr\n"
"              Read cdr format (default is wav). Sets the correct byte order.\n"
"\n"
"       --infile, -r NAME\n"
"              Input filename. Defaults to stdin. '-' = stdin.\n"
"\n"
"       --inlittle, -i\n"
"              Input data is little endian (LSB, MSB) (Intel).\n"
"\n"
"       --inraw\n"
"              Read raw format. Byte  order  should  be  specified  with  -i/-I\n"
"              (default big).\n"
"\n"
"       --inwav\n"
"              Read wav format (default). Sets the correct byte order.\n"
"\n"
"       --iscale NUM\n"
"              Scale data to NUM percent (100 does nothing).\n"
"\n"
"       --monostereo\n"
"              Convert input to mono and immediately back to stereo. The result\n"
"              is 2 channels with the same data. This can  be  useful  in  some\n"
"              cases.\n"
"\n"
"       --noswapchannels\n"
"              Don't swap channels. (default)\n"
"\n"
"       --outfile, -w NAME\n"
"              Write  output  to  file NAME.  The track number is appended as a\n"
"              2-digit number.  The default is to write output  to  stdout.   A\n"
"              NAME  of '-' means stdout.  When cutting is active and more than\n"
"              one cut is made, output can not be written to stdout and the use\n"
"              of this option is mandatory.\n"
"\n"
"       --outbig, -O\n"
"              Output data in big endian (MSB, LSB) (Motorola) byte order.\n"
"\n"
"       --outlittle, -o\n"
"              Output data in little endian (LSB, MSB) (Intel) byte order.\n"
"\n"
"       --quiet\n"
"              Suppress progress output.  The name of this option might be mis-\n"
"              leading: it does not prevent  copious  output  in  other  places\n"
"              which might be turned on by --verbose.\n"
"\n"
"       --silencecuts\n"
"              Generate  cut  numbers for cutting out silent intervals. This is\n"
"              useful when digitising a whole record and then cutting  it  into\n"
"              tracks. The cut numbers are output on stdout and can be fed back\n"
"              into --cut.  After cutting, every second track (those with  even\n"
"              numbers) contains a silent interval and can be deleted.\n"
"\n"
"              Together  with  --verbose,  the  silence value of each sector is\n"
"              printed as well (can't be fed back into --cut then).  This  most\n"
"              likely produces some VERY long lines.\n"
"\n"
"              Silence is detected by applying a threshold (--silencethresh) to\n"
"              a value computed for each CD sector; the value must be below the\n"
"              threshold  for  a  minimum number of sectors (delay --silencede-\n"
"              lay). Currently, the average is computed first (this is  the  DC\n"
"              component);  then  the average of the absolute of the difference\n"
"              between each sample and the DC component. The difference between\n"
"              these  2  averages is compared with the threshold. Check whether\n"
"              the cuts really fall  into  the  silent  intervals,  and  adjust\n"
"              threshold  and  duration  if  not (or edit the cut numbers manu-\n"
"              ally).\n"
"\n"
"              The silence delay period is part of the signal interval, not the\n"
"              silence  interval.  This  means  that each non-silent period has\n"
"              --silencedelay silence at the start  and  at  the  end.  If  the\n"
"              silent  interval  between two signal intervals is less than (2 *\n"
"              silence delay), the silent part at the start of the second  sig-\n"
"              nal period will be shortened.\n"
"\n"
"       --silencedelay DELAY\n"
"              The  duration  for which the \x22""input\x22"" must be below the threshold\n"
"              in order to be detected as a silent interval.  In  other  words,\n"
"              the  number  of  sectors  which  must  be silent before a silent\n"
"              interval is detected. Ignored without --silencecuts.  The  delay\n"
"              can be specified with units in the same way as for --cut, and is\n"
"              truncated to full CD sectors. Default is 30C (=0.4s).\n"
"\n"
"       --silenceinfo\n"
"              Similar to --silencecuts, but  it  generates  more  information.\n"
"              Silent  and non-silent intervals are listed in a tabular format.\n"
"              The output format is useful for documentation, but not for feed-\n"
"              ing back into --cut.  With --verbose, the silence values of each\n"
"              CD sector are shown as well.  This produces lots of output,  but\n"
"              it is useful for finding a suitable --silencethresh.\n"
"\n"
"       --silencethresh THRESHOLD\n"
"              Threshold  for silence detection. Ignored without --silencecuts.\n"
"              Default is 10. Always select a threshold  as  low  as  possible.\n"
"              When  cutting  a  record into tracks, the threshold must be high\n"
"              enough to recognise the crackling  between  pieces  as  silence.\n"
"              When  the  threshold  is too high, a little at the beginning and\n"
"              end of each piece might be chopped off.\n"
"\n"
"              As a special case, if the threshold is set to 0 the usual numer-\n"
"              ical  computation of the silence value is bypassed, and the sec-\n"
"              tor is deemed to be silent if all samples are 0.\n"
"\n"
"       --startsilence, --ss DUR\n"
"              Adds the given amount of silence to the  start  of  each  output\n"
"              file.\n"
"\n"
"       --swapchannels\n"
"              Swap the left with the right channel.\n"
"\n"
"       --tocdr\n"
"              Write data in cdr format (default). Sets the correct byte order.\n"
"\n"
"       --toraw\n"
"              Write data in raw format. Byte order should  be  specified  with\n"
"              -o/-O (default big).\n"
"\n"
"       --towav\n"
"              Write data in wav format. Sets the correct byte order.\n"
"\n"
"       --verbose\n"
"              Produce  more  output.  Currently only used by --silencecuts and\n"
"              --silenceinfo.\n"
"\n"
"       --version, -V\n"
"              Display version information.\n"
"\n"
"       --     Stop argument processing.  Remaining arguments can only be file-\n"
"              names, or cut numbers if cutting is used.\n"
"\n"
"Command line option scanning:\n"
"       From  left  to right. Later settings may override previous ones. Beware\n"
"       to switch file formats before byte ordering, or a byte order  might  be\n"
"       rejected  for the (then active) format. When not using cutting, remain-\n"
"       ing arguments are used to fill up  input  and  output  filenames.  When\n"
"       using  cutting, remaining arguments are assumed to be cut numbers. When\n"
"       using negative cut numbers, use -- to terminate  option  processing  or\n"
"       the  negative  numbers  can be mistaken as options (this is a must with\n"
"       GNU getopt()).\n"
"\n"
"       All options which take an argument denoting a time accept the following\n"
"       number format. The number may be in decimal, octal (leading 0), or hex-\n"
"       adecimal (leading 0x or 0X). A one-letter unit  may  be  following.  If\n"
"       there is space between the number and the unit, both must be quoted, as\n"
"       in \x22""55 C\x22"". These units are recognised: b (bytes), C (audio CD sectors),\n"
"       s  (seconds). When no unit is given, C is assumed. The progress display\n"
"       might only show numbers in some of these units. Fractions  for  seconds\n"
"       are allowed.\n"
"\n"
"       Negative  cut  numbers are only allowed if the input size can be deter-\n"
"       mined (which will not be possible if the input comes from a pipe),  and\n"
"       are  shown as the equivalent positive ones. If the last cut number is 0\n"
"       it means the end of the file. If the input file size can not be  deter-\n"
"       mined the longest possible input (about 405 minutes) is substituted.\n"
"\n"
"       A filename of '-' is taken as stdin/stdout.\n"
"\n"
"       If  wav2cdr was compiled to use GNU getopt(), argument scanning is more\n"
"       powerful and long options can be shortened to significance. Options are\n"
"       also  re-ordered;  this  is nice but can be a trap. Use -- if in doubt,\n"
"       and don't mix options with filename or cut number arguments.\n"
"\n"
"Data formats:\n"
"       All data handling currently assumes signed 16-bit integers, interleaved\n"
"       for 2 channels, at a sampling rate of that of a CD. Only wav files with\n"
"       these parameters can be read correctly. cdr files are in  that  format,\n"
"       and  only  raw formats with these parameters can be processed. The only\n"
"       flexibility allowed for raw is the byte order, which can  be  specified\n"
"       for  both  reading  and  writing.  The byte ordering for wav and cdr is\n"
"       fixed.\n"
"\n"
"Channel swapping:\n"
"       Left and right channel are swapped, which is the same as swapping  con-\n"
"       secutive 16 bit values with each other. Also see 'CDR Format' below.\n"
"\n"
"Scaling / Volume change:\n"
"       Scaling  can  be performed with either integer or floating point arith-\n"
"       metic.  Integer arithmatic is faster but possibly not as precise.  Val-\n"
"       ues  will  saturate  (i.e.  be  clipped), rather than be truncated. The\n"
"       speed of this operation depends on the endianness of  the  input  data,\n"
"       output  data,  and  host.  It  is slowest when bytes have to be swapped\n"
"       before scaling and swapped back  after.   Negative  scale  factors  are\n"
"       allowed but might be of dubious value.\n"
"\n"
"Mono / stereo:\n"
"       Input data can be converted to mono and then back to stereo. The result\n"
"       is 2 channels with the same data. This can be useful in some cases.\n"
"\n"
"Output file naming:\n"
"       Unless output is to stdout, the resulting filename is  the  name  given\n"
"       with --outfile. A period and a 2-digit track number are appended.\n"
"\n"
"Input data splitting:\n"
"       Input  data  can  be split into pieces resp. tracks. Currently cuts can\n"
"       only be placed at multiples of audio CD sectors (at the  sector  bound-\n"
"       aries), whether the input format is cdr or not.\n"
"\n"
"       The  cuts are placed at the given positions, which must be in ascending\n"
"       order (or equal). Negative numbers are counted  from  the  end  of  the\n"
"       input  data.  This  only works if the input is seekable (Unix pipes are\n"
"       not). Sectors of the input are numbered from  0.  Bytes  of  a  header,\n"
"       which the input format might have, are not counted.\n"
"\n"
"       Any  number of cuts can be made, but only 99 tracks can be put on a CD.\n"
"       All sectors before the first but not including the first sector  number\n"
"       are discarded, as well as all sectors after and including the last sec-\n"
"       tor number.  At least 2 sector numbers (cut numbers) must be given,  in\n"
"       which case one piece is cut out.\n"
"\n"
"       If  there are only 2 cut numbers (1 track to cut out) data can be writ-\n"
"       ten to stdout or file. More than one track can only be written to file,\n"
"       the  track  number  will  be added as an extension to the filename.  To\n"
"       avoid the track number to be appended to the filename when only one cut\n"
"       is  made,  don't use --outfile but write to stdout and use output redi-\n"
"       rection.\n"
"\n"
"        Example (assuming 50000 sectors in the input):\n"
"           wav2cdr < INPUT --outfile NAME --cut 500 20000 40000\n"
"                sectors     0-  499: discarded\n"
"                          500-19999: saved to NAME.01\n"
"                        20000-39999: saved to NAME.02\n"
"                        40000-49999: discarded\n"
"\n"
"Cutting out silent intervals:\n"
"       Assuming a digitised record is stored in record.wav, and is to  be  cut\n"
"       into tracks.\n"
"\n"
"         wav2cdr < record.wav > cuts --silencecuts --silencedelay 2s\n"
"         wav2cdr < record.wav --of tracks --cut `cat cuts`\n"
"\n"
"       Will  store  the  tracks of the record in track.01, track.02, ..., with\n"
"       the delay for cutting at a silent part set to 2 seconds. The  threshold\n"
"       used  is  the  default. Note the `` syntax works under Unix and in this\n"
"       case puts the contents of file \x22""cuts\x22"" on the command line.\n"
"\n"
"Information about silences and actual sound parts:\n"
"       --silenceinfo can be used in the same way as  --silencecuts.   It  pro-\n"
"       duces output like\n"
"\n"
"       (stdin):\n"
"        silnc         0 b,      0 C,    0 s, 00:00.00 min\n"
"         DIFF    811440 b,    345 C,    4 s, 00:04.22 min\n"
"          -->    811440 b,    345 C,    4 s, 00:04.22 min\n"
"\n"
"        AUDIO    811440 b,    345 C,    4 s, 00:04.22 min\n"
"         DIFF  20603520 b,   8760 C,  116 s, 01:56.05 min\n"
"          -->  21414960 b,   9105 C,  121 s, 02:01.02 min\n"
"\n"
"       showing  the beginning, length (\x22""DIFF\x22""), and end (\x22""-->\x22"") of both silent\n"
"       (\x22""silnc\x22"") and and non-silent (\x22""AUDIO\x22"") intervals. This  is  useful  for\n"
"       examining existing tracks, but it can not be used with --cut.\n"
"\n"
"Messages:\n"
"       Progress  messages and statistics are written to stderr when writing to\n"
"       stdout, and to stdout when writing to file. It is currently not  possi-\n"
"       ble to suppress this, other than by redirection to the bit bucket.\n"
"\n"
"Writing wav format:\n"
"       Only  wav  files with 2 channels, 16 bits per sample, and audio CD sam-\n"
"       pling rate can be written. If the input data is different, the  result-\n"
"       ing  wav  file is incorrect. Scaling can be performed when writing wav.\n"
"       Cutting can only be performed in multiples of an audio CD sector  size.\n"
"       When writing wav the output must be seekable (e.g. no pipes).\n"
"\n"
"CDR Format:\n"
"       Raw sample data at a sampling rate of %li Hz. The channels are inter-\n"
"       leaved.  The numbers are 16 bit signed integers with this  byte  order:\n"
"       MSByte  Left,  LSByte Left, MSByte Right, LSByte Right.  The track size\n"
"       must be a multiple of the sector size of %i bytes.  There are %i sec-\n"
"       tors per second.\n"
"\n"
"BUGS / LIMITATIONS\n"
"       All  operations  can  only be performed on a minimum of 1 CD block or a\n"
"       multiple thereof.\n"
"\n"
"COPYRIGHT\n"
"       Copyright (C)\n"
"       Nov, Dec 1997, Jan, Mar, Apr, May 1998, Feb, May, Jun, Jul,\n"
"       Aug 1999, Oct 2000, Jan 2006 by\n"
"       Volker Kuhlmann  <VolkerKuhlmann@gmx.de>\n"
"       formerly c/o EEE Dept, University of Canterbury\n"
"       Christchurch, New Zealand\n"
"\n"
"       Permission granted to use and distribute this software free of  charge,\n"
"       provided any improvements are sent back to the author. Comments and bug\n"
"       reports welcome.  All rights reserved. Standard disclaimer applies.\n"
"\n"
"AUTHOR\n"
"       Volker Kuhlmann\n"
"\n"
"wav2cdr                           18 Jan 2006                       wav2cdr(1)\n"
